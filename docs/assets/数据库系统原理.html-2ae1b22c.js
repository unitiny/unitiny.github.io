import{_ as g,W as t,X as n,Y as a,Z as i,a0 as s,a2 as r,C as d}from"./framework-5d92cd28.js";const c="/assets/image-20220905192912643-1d717ed0.png",o="/assets/image-20220830191758416-666e0df5.png",m="/assets/image-20220831101443754-3fc38493.png",l="/assets/image-20220831101527411-304a7a96.png",p="/assets/image-20220831103745757-da6095d7.png",f="/assets/image-20220905192726956-dd760896.png",h="/assets/image-20220831212033487-0c542c72.png",u="/assets/image-20220905193140323-bc823498.png",b="/assets/image-20220901095246653-8024886b.png",_="/assets/image-20220901100521759-8a6b01ea.png",x="/assets/image-20220901100639764-04838444.png",y="/assets/image-20220901100849468-14accfb2.png",v="/assets/image-20220901140112768-ebafba6b.png",z="/assets/image-20220901140026232-b6051793.png",A="/assets/image-20220901142840928-b54207e9.png",B="/assets/image-20220901143447716-7440157b.png",E="/assets/image-20220905162845451-2bc76059.png",R="/assets/image-20220905163105724-356d2506.png",C="/assets/image-20220905162921093-28f265bf.png",L="/assets/image-20220905163533433-83c81229.png",V="/assets/image-20220902151247836-87b806c1.png",I="/assets/image-20220902151517111-bb7a5b72.png",N="/assets/image-20220902153518154-14e7e26f.png",S="/assets/image-20220902153536442-2f386114.png",k="/assets/image-20220903091012634-e62ce4d4.png",U="/assets/image-20220903091119027-76ea3791.png",Y="/assets/image-20220903091229086-779818a2.png",w="/assets/image-20220904154326627-f5c9b919.png",D="/assets/image-20220904154630598-8bef1cd6.png",H="/assets/image-20220904161926021-d6b92e3e.png",M="/assets/image-20220904164534781-56a1720b.png",q="/assets/image-20220904191117081-054dde82.png",G="/assets/image-20220904191544575-06593e8d.png",K="/assets/image-20220904191634491-737c7b87.png",O="/assets/image-20220904191844927-055a794b.png",P="/assets/image-20220904193409563-b6e2cdd9.png",Q="/assets/image-20220905194221225-5666e6c5.png",T="/assets/image-20220904193637589-9a836d41.png",X="/assets/image-20220904193613590-f6ac59e8.png",W="/assets/image-20220904193657100-5c2b9c53.png",Z="/assets/image-20220904194101342-0d716b89.png",j="/assets/image-20220905093337326-2fcf43b1.png",F="/assets/image-20220905094326786-9296afdf.png",J="/assets/image-20220905095939749-142da46e.png",$="/assets/image-20220905100059007-b32c3fd9.png",aa="/assets/image-20220905101234745-137c0819.png",ia="/assets/image-20220905101654767-73ba906d.png",ea="/assets/image-20220905110612206-2c506bfa.png",ga="/assets/image-20220905111307694-6d726a8b.png",ta="/assets/image-20220905111245591-76c5ee88.png",na="/assets/image-20220905111542799-f61171bc.png",sa="/assets/image-20220905112032713-437cd605.png",ra="/assets/image-20220905112000798-acd1a111.png",da="/assets/image-20220905112307805-7a25433d.png",ca="/assets/image-20220905112325189-59b29a3e.png",oa="/assets/image-20220905112508290-fa88e18b.png",ma="/assets/image-20220905112448491-36681550.png",la="/assets/image-20220905144251342-88aa7096.png",pa="/assets/image-20220905144316169-aeaeaae4.png",fa="/assets/image-20220905144510784-b16867be.png",ha="/assets/image-20220905145525632-b0b013d6.png",ua="/assets/image-20220905153139484-c2348069.png",ba="/assets/image-20220905154635897-46c0c4b6.png",_a="/assets/image-20220905160115543-083df1c8.png",xa="/assets/image-20220905160137503-fc2f5cc8.png",ya="/assets/image-20220905160932480-677ed127.png",va="/assets/image-20220905160336335-821cc517.png",za="/assets/image-20220915095320558-df965606.png",Aa={},Ba=a("h2",{id:"学习",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#学习","aria-hidden":"true"},"#"),i(" 学习")],-1),Ea={href:"https://www.bilibili.com/video/BV1ra4y1t7xY?p=7&spm_id_from=pageDriver&vd_source=3ec975651088fba288a277c53f0bcc77",target:"_blank",rel:"noopener noreferrer"},Ra=r('<p>XMind有整理图谱</p><h2 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h2><h3 id="主码和主属性" tabindex="-1"><a class="header-anchor" href="#主码和主属性" aria-hidden="true">#</a> 主码和主属性</h3><p>主码必须是唯一标识，可不只是用一个属性来充当，为满足唯一需求，可以两个属性组合作为主码 主码中的各属性称为主属性</p><h3 id="数据模型三要素" tabindex="-1"><a class="header-anchor" href="#数据模型三要素" aria-hidden="true">#</a> 数据模型三要素</h3><p>数据结构，数据操作，完整性约束</p><h3 id="实体完整性和参照完整性" tabindex="-1"><a class="header-anchor" href="#实体完整性和参照完整性" aria-hidden="true">#</a> 实体完整性和参照完整性</h3><p>实例中的主码必须符合主码的取值约束，即满足实体完整性</p><p>实例中的外码必须符合外码的取值约束，即满足参照完整性</p><h3 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h3><p>CHAR 固定长度字符串，尾部空格不会去掉，即使未满也会占用</p><p>VARCHAR 可变长度字符串，尾部空格会去掉，有剩余空间会留给其他变量使用</p><p>decimal 精确的数据类型</p><h3 id="约束" tabindex="-1"><a class="header-anchor" href="#约束" aria-hidden="true">#</a> 约束</h3><p>PRIMARY KEY 主键</p><p>UNIQUE 唯一值，不能重复</p><figure><img src="'+c+'" alt="image-20220905192912643" tabindex="0" loading="lazy"><figcaption>image-20220905192912643</figcaption></figure><figure><img src="'+o+'" alt="image-20220830191758416" tabindex="0" loading="lazy"><figcaption>image-20220830191758416</figcaption></figure><h3 id="关系代数" tabindex="-1"><a class="header-anchor" href="#关系代数" aria-hidden="true">#</a> 关系代数</h3><figure><img src="'+m+'" alt="image-20220831101443754" tabindex="0" loading="lazy"><figcaption>image-20220831101443754</figcaption></figure><figure><img src="'+l+'" alt="image-20220831101527411" tabindex="0" loading="lazy"><figcaption>image-20220831101527411</figcaption></figure><figure><img src="'+p+'" alt="image-20220831103745757" tabindex="0" loading="lazy"><figcaption>image-20220831103745757</figcaption></figure><h3 id="sql" tabindex="-1"><a class="header-anchor" href="#sql" aria-hidden="true">#</a> SQL</h3><figure><img src="'+f+'" alt="image-20220905192726956" tabindex="0" loading="lazy"><figcaption>image-20220905192726956</figcaption></figure><h3 id="创建表" tabindex="-1"><a class="header-anchor" href="#创建表" aria-hidden="true">#</a> 创建表</h3><figure><img src="'+h+'" alt="image-20220831212033487" tabindex="0" loading="lazy"><figcaption>image-20220831212033487</figcaption></figure><h3 id="更改表" tabindex="-1"><a class="header-anchor" href="#更改表" aria-hidden="true">#</a> 更改表</h3><figure><img src="'+u+'" alt="image-20220905193140323" tabindex="0" loading="lazy"><figcaption>image-20220905193140323</figcaption></figure><h3 id="单表查询" tabindex="-1"><a class="header-anchor" href="#单表查询" aria-hidden="true">#</a> 单表查询</h3><h4 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> SELECT</h4><p>select语句先从from开始执行，最后才是select 列名</p><p>year(getdate()) 获取当前时间的年份</p><p>distinct 去除重复元组</p><figure><img src="'+b+'" alt="image-20220901095246653" tabindex="0" loading="lazy"><figcaption>image-20220901095246653</figcaption></figure><p>\\ 转义字符</p><figure><img src="'+_+'" alt="image-20220901100521759" tabindex="0" loading="lazy"><figcaption>image-20220901100521759</figcaption></figure><figure><img src="'+x+'" alt="image-20220901100639764" tabindex="0" loading="lazy"><figcaption>image-20220901100639764</figcaption></figure><p>先Sdept升序排，Sdept相等则按Sage降序排</p><figure><img src="'+y+'" alt="image-20220901100849468" tabindex="0" loading="lazy"><figcaption>image-20220901100849468</figcaption></figure><h4 id="group-by" tabindex="-1"><a class="header-anchor" href="#group-by" aria-hidden="true">#</a> GROUP BY</h4><figure><img src="'+v+'" alt="image-20220901140112768" tabindex="0" loading="lazy"><figcaption>image-20220901140112768</figcaption></figure><h4 id="having" tabindex="-1"><a class="header-anchor" href="#having" aria-hidden="true">#</a> HAVING</h4><p>是在分组后的结果再筛选</p><figure><img src="'+z+'" alt="image-20220901140026232" tabindex="0" loading="lazy"><figcaption>image-20220901140026232</figcaption></figure><h3 id="连接查询" tabindex="-1"><a class="header-anchor" href="#连接查询" aria-hidden="true">#</a> 连接查询</h3><h4 id="等值连接" tabindex="-1"><a class="header-anchor" href="#等值连接" aria-hidden="true">#</a> 等值连接</h4><figure><img src="'+A+'" alt="image-20220901142840928" tabindex="0" loading="lazy"><figcaption>image-20220901142840928</figcaption></figure><h4 id="自身连接" tabindex="-1"><a class="header-anchor" href="#自身连接" aria-hidden="true">#</a> 自身连接</h4><figure><img src="'+B+'" alt="image-20220901143447716" tabindex="0" loading="lazy"><figcaption>image-20220901143447716</figcaption></figure><h4 id="内连接" tabindex="-1"><a class="header-anchor" href="#内连接" aria-hidden="true">#</a> 内连接</h4><figure><img src="'+E+'" alt="image-20220905162845451" tabindex="0" loading="lazy"><figcaption>image-20220905162845451</figcaption></figure><h4 id="外连接" tabindex="-1"><a class="header-anchor" href="#外连接" aria-hidden="true">#</a> 外连接</h4><figure><img src="'+R+'" alt="image-20220905163105724" tabindex="0" loading="lazy"><figcaption>image-20220905163105724</figcaption></figure><h5 id="左连接" tabindex="-1"><a class="header-anchor" href="#左连接" aria-hidden="true">#</a> 左连接</h5><p>返回select中左表的全部数据，包含两表等值连接的结果和剩余左表未匹配的结果</p><figure><img src="'+C+'" alt="image-20220905162921093" tabindex="0" loading="lazy"><figcaption>image-20220905162921093</figcaption></figure><figure><img src="'+L+'" alt="image-20220905163533433" tabindex="0" loading="lazy"><figcaption>image-20220905163533433</figcaption></figure><h3 id="嵌套查询" tabindex="-1"><a class="header-anchor" href="#嵌套查询" aria-hidden="true">#</a> 嵌套查询</h3><p>select中嵌套子查询select</p><figure><img src="'+V+'" alt="image-20220902151247836" tabindex="0" loading="lazy"><figcaption>image-20220902151247836</figcaption></figure><figure><img src="'+I+'" alt="image-20220902151517111" tabindex="0" loading="lazy"><figcaption>image-20220902151517111</figcaption></figure><figure><img src="'+N+'" alt="image-20220902153518154" tabindex="0" loading="lazy"><figcaption>image-20220902153518154</figcaption></figure><figure><img src="'+S+`" alt="image-20220902153536442" tabindex="0" loading="lazy"><figcaption>image-20220902153536442</figcaption></figure><h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h3><h4 id="delete-和-truncate区别" tabindex="-1"><a class="header-anchor" href="#delete-和-truncate区别" aria-hidden="true">#</a> delete 和 truncate区别</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>delete from sc;
truncate table sc;
功能都是清空表的数据，但是清空的方式不同。

delete是一行一行数据删除
truncate实际执行两个命令，drop table sc; create table sc();
先删除表，再创建空表。当数据量大时，truncate的速度较快
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="视图" tabindex="-1"><a class="header-anchor" href="#视图" aria-hidden="true">#</a> 视图</h3><figure><img src="`+k+'" alt="image-20220903091012634" tabindex="0" loading="lazy"><figcaption>image-20220903091012634</figcaption></figure><figure><img src="'+U+'" alt="image-20220903091119027" tabindex="0" loading="lazy"><figcaption>image-20220903091119027</figcaption></figure><p>创建视图 ，创建时并不执行select，只有查询时才使用</p><figure><img src="'+Y+`" alt="image-20220903091229086" tabindex="0" loading="lazy"><figcaption>image-20220903091229086</figcaption></figure><h3 id="e-r图" tabindex="-1"><a class="header-anchor" href="#e-r图" aria-hidden="true">#</a> E-R图</h3><h4 id="如何设计数据库" tabindex="-1"><a class="header-anchor" href="#如何设计数据库" aria-hidden="true">#</a> 如何设计数据库</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1 列需求选名词，即将独立的对象抽离出来
2 再列出对象里面的属性
3 如果对象属性还可以拆分的话，可以抽离出新的对象，并建立关系
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+w+'" alt="image-20220904154326627" tabindex="0" loading="lazy"><figcaption>image-20220904154326627</figcaption></figure><figure><img src="'+D+'" alt="image-20220904154630598" tabindex="0" loading="lazy"><figcaption>image-20220904154630598</figcaption></figure><h4 id="转换关系模式" tabindex="-1"><a class="header-anchor" href="#转换关系模式" aria-hidden="true">#</a> 转换关系模式</h4><figure><img src="'+H+'" alt="image-20220904161926021" tabindex="0" loading="lazy"><figcaption>image-20220904161926021</figcaption></figure><h3 id="uml" tabindex="-1"><a class="header-anchor" href="#uml" aria-hidden="true">#</a> UML</h3><figure><img src="'+M+'" alt="image-20220904164534781" tabindex="0" loading="lazy"><figcaption>image-20220904164534781</figcaption></figure><h3 id="规范化理论" tabindex="-1"><a class="header-anchor" href="#规范化理论" aria-hidden="true">#</a> 规范化理论</h3><p>对表的合理设计进行衡量，理清冗余数据和不合理的数据依赖</p><h4 id="函数依赖" tabindex="-1"><a class="header-anchor" href="#函数依赖" aria-hidden="true">#</a> 函数依赖</h4><figure><img src="'+q+'" alt="image-20220904191117081" tabindex="0" loading="lazy"><figcaption>image-20220904191117081</figcaption></figure><figure><img src="'+G+'" alt="image-20220904191544575" tabindex="0" loading="lazy"><figcaption>image-20220904191544575</figcaption></figure><figure><img src="'+K+'" alt="image-20220904191634491" tabindex="0" loading="lazy"><figcaption>image-20220904191634491</figcaption></figure><figure><img src="'+O+`" alt="image-20220904191844927" tabindex="0" loading="lazy"><figcaption>image-20220904191844927</figcaption></figure><h4 id="范式" tabindex="-1"><a class="header-anchor" href="#范式" aria-hidden="true">#</a> 范式</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>第一范式 所有属性都是不可分的基本数据项
第二范式 不存在非主属性中有部分函数依赖
第三范式 不存在非主属性中有传递函数依赖
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+P+'" alt="image-20220904193409563" tabindex="0" loading="lazy"><figcaption>image-20220904193409563</figcaption></figure><figure><img src="'+Q+'" alt="image-20220905194221225" tabindex="0" loading="lazy"><figcaption>image-20220905194221225</figcaption></figure><figure><img src="'+T+'" alt="image-20220904193637589" tabindex="0" loading="lazy"><figcaption>image-20220904193637589</figcaption></figure><h4 id="坏的关系模式" tabindex="-1"><a class="header-anchor" href="#坏的关系模式" aria-hidden="true">#</a> 坏的关系模式</h4><p>依赖过多，说了太多的事情</p><figure><img src="'+X+'" alt="image-20220904193613590" tabindex="0" loading="lazy"><figcaption>image-20220904193613590</figcaption></figure><figure><img src="'+W+'" alt="image-20220904193657100" tabindex="0" loading="lazy"><figcaption>image-20220904193657100</figcaption></figure><p>还得把传递函数依赖分解</p><figure><img src="'+Z+'" alt="image-20220904194101342" tabindex="0" loading="lazy"><figcaption>image-20220904194101342</figcaption></figure><h3 id="安全控制" tabindex="-1"><a class="header-anchor" href="#安全控制" aria-hidden="true">#</a> 安全控制</h3><h4 id="权限" tabindex="-1"><a class="header-anchor" href="#权限" aria-hidden="true">#</a> 权限</h4><figure><img src="'+j+'" alt="image-20220905093337326" tabindex="0" loading="lazy"><figcaption>image-20220905093337326</figcaption></figure><figure><img src="'+F+'" alt="image-20220905094326786" tabindex="0" loading="lazy"><figcaption>image-20220905094326786</figcaption></figure><figure><img src="'+J+'" alt="image-20220905095939749" tabindex="0" loading="lazy"><figcaption>image-20220905095939749</figcaption></figure><p>同时把U5授权给其他用户的权限也收回</p><figure><img src="'+$+'" alt="image-20220905100059007" tabindex="0" loading="lazy"><figcaption>image-20220905100059007</figcaption></figure><h3 id="并发控制" tabindex="-1"><a class="header-anchor" href="#并发控制" aria-hidden="true">#</a> 并发控制</h3><figure><img src="'+aa+'" alt="image-20220905101234745" tabindex="0" loading="lazy"><figcaption>image-20220905101234745</figcaption></figure><h4 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h4><figure><img src="'+ia+`" alt="image-20220905101654767" tabindex="0" loading="lazy"><figcaption>image-20220905101654767</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>事务交叉并发可能产生的问题
数据不一致（有读写的操作同时执行，导致读取数据出错）
幻行（插入，删除操作同时有读取的事务在执行，导致结果行数缺少或增多）
读脏数据（A事务更新数据，B事务而后读取，然后A事务ROLLBACK回滚，导致B读取出错）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h4><figure><img src="`+ea+'" alt="image-20220905110612206" tabindex="0" loading="lazy"><figcaption>image-20220905110612206</figcaption></figure><figure><img src="'+ga+'" alt="image-20220905111307694" tabindex="0" loading="lazy"><figcaption>image-20220905111307694</figcaption></figure><figure><img src="'+ta+'" alt="image-20220905111245591" tabindex="0" loading="lazy"><figcaption>image-20220905111245591</figcaption></figure><figure><img src="'+na+`" alt="image-20220905111542799" tabindex="0" loading="lazy"><figcaption>image-20220905111542799</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>两段锁协议，即加锁就连续加锁知道解锁操作，解锁后面就全部解锁，不能再加锁
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="活锁" tabindex="-1"><a class="header-anchor" href="#活锁" aria-hidden="true">#</a> 活锁</h4><p>加锁时一直等待，申请不到加锁机会，可通过先来先调度解决</p><figure><img src="`+sa+'" alt="image-20220905112032713" tabindex="0" loading="lazy"><figcaption>image-20220905112032713</figcaption></figure><h4 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h4><figure><img src="'+ra+'" alt="image-20220905112000798" tabindex="0" loading="lazy"><figcaption>image-20220905112000798</figcaption></figure><p>普通方案解决</p><figure><img src="'+da+'" alt="image-20220905112307805" tabindex="0" loading="lazy"><figcaption>image-20220905112307805</figcaption></figure><figure><img src="'+ca+'" alt="image-20220905112325189" tabindex="0" loading="lazy"><figcaption>image-20220905112325189</figcaption></figure><p>符合DB的解决方案</p><figure><img src="'+oa+'" alt="image-20220905112508290" tabindex="0" loading="lazy"><figcaption>image-20220905112508290</figcaption></figure><figure><img src="'+ma+`" alt="image-20220905112448491" tabindex="0" loading="lazy"><figcaption>image-20220905112448491</figcaption></figure><h3 id="错误恢复" tabindex="-1"><a class="header-anchor" href="#错误恢复" aria-hidden="true">#</a> 错误恢复</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>通过转储和重新运行故障前的事务来恢复
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+la+'" alt="image-20220905144251342" tabindex="0" loading="lazy"><figcaption>image-20220905144251342</figcaption></figure><figure><img src="'+pa+'" alt="image-20220905144316169" tabindex="0" loading="lazy"><figcaption>image-20220905144316169</figcaption></figure><figure><img src="'+fa+'" alt="image-20220905144510784" tabindex="0" loading="lazy"><figcaption>image-20220905144510784</figcaption></figure><h3 id="数据库复制" tabindex="-1"><a class="header-anchor" href="#数据库复制" aria-hidden="true">#</a> 数据库复制</h3><figure><img src="'+ha+'" alt="image-20220905145525632" tabindex="0" loading="lazy"><figcaption>image-20220905145525632</figcaption></figure><h3 id="完整性控制" tabindex="-1"><a class="header-anchor" href="#完整性控制" aria-hidden="true">#</a> 完整性控制</h3><figure><img src="'+ua+'" alt="image-20220905153139484" tabindex="0" loading="lazy"><figcaption>image-20220905153139484</figcaption></figure><p>参照关系操作</p><figure><img src="'+ba+'" alt="image-20220905154635897" tabindex="0" loading="lazy"><figcaption>image-20220905154635897</figcaption></figure><p>表级完整性</p><figure><img src="'+_a+'" alt="image-20220905160115543" tabindex="0" loading="lazy"><figcaption>image-20220905160115543</figcaption></figure><p>列级完整性</p><figure><img src="'+xa+'" alt="image-20220905160137503" tabindex="0" loading="lazy"><figcaption>image-20220905160137503</figcaption></figure><p>列约束</p><figure><img src="'+ya+'" alt="image-20220905160932480" tabindex="0" loading="lazy"><figcaption>image-20220905160932480</figcaption></figure><h4 id="参照完整性" tabindex="-1"><a class="header-anchor" href="#参照完整性" aria-hidden="true">#</a> 参照完整性</h4><figure><img src="'+va+'" alt="image-20220905160336335" tabindex="0" loading="lazy"><figcaption>image-20220905160336335</figcaption></figure><h3 id="acid" tabindex="-1"><a class="header-anchor" href="#acid" aria-hidden="true">#</a> ACID</h3><figure><img src="'+za+'" alt="image-20220915095320558" tabindex="0" loading="lazy"><figcaption>image-20220915095320558</figcaption></figure>',148);function Ca(La,Va){const e=d("ExternalLinkIcon");return t(),n("div",null,[Ba,a("p",null,[a("a",Ea,[i("网址"),s(e)])]),Ra])}const Na=g(Aa,[["render",Ca],["__file","数据库系统原理.html.vue"]]);export{Na as default};
