const e=JSON.parse('{"key":"v-2e9a7b20","path":"/posts/%E5%90%8E%E7%AB%AF/Go/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Gee.html","title":"Gee","lang":"en-US","frontmatter":{"icon":"article","date":"2022-01-10T00:00:00.000Z","title":"Gee","category":["后端","Go","项目笔记"],"tag":["Gee"],"description":"Gee 介绍： web框架 知识点： 为什么要设计上下文？ 1 对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter。但是这两个对象提供的 接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含 了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效 的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。 2 针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由/hello/:name， 参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一 个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件， 参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E5%90%8E%E7%AB%AF/Go/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/Gee.html"}],["meta",{"property":"og:site_name","content":"unitiny的宇宙"}],["meta",{"property":"og:title","content":"Gee"}],["meta",{"property":"og:description","content":"Gee 介绍： web框架 知识点： 为什么要设计上下文？ 1 对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter。但是这两个对象提供的 接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含 了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效 的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。 2 针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由/hello/:name， 参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一 个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件， 参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-07-25T09:20:57.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Gee"}],["meta",{"property":"article:author","content":"unitiny"}],["meta",{"property":"article:tag","content":"Gee"}],["meta",{"property":"article:published_time","content":"2022-01-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-25T09:20:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Gee\\",\\"image\\":[\\"https://mister-hope.github.io/\\"],\\"datePublished\\":\\"2022-01-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-25T09:20:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"unitiny\\",\\"url\\":\\"#\\"}]}"]]},"headers":[{"level":2,"title":"Gee","slug":"gee","link":"#gee","children":[{"level":3,"title":"介绍：","slug":"介绍","link":"#介绍","children":[]},{"level":3,"title":"知识点：","slug":"知识点","link":"#知识点","children":[]},{"level":3,"title":"难点：","slug":"难点","link":"#难点","children":[]}]}],"git":{"createdTime":1721899257000,"updatedTime":1721899257000,"contributors":[{"name":"unitiny","email":"2069234934@qq.com","commits":1}]},"readingTime":{"minutes":1.75,"words":525},"filePathRelative":"posts/后端/Go/项目笔记/Gee.md","localizedDate":"January 10, 2022","excerpt":"<h2> Gee</h2>\\n<h3> 介绍：</h3>\\n<p>web框架</p>\\n<h3> 知识点：</h3>\\n<p>为什么要设计上下文？</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>1 对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter。但是这两个对象提供的\\n接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含\\n了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效\\n的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 \\nHTTP 响应是一个好的框架必须考虑的点。\\n\\n2 针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计 \\nContext 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由/hello/:name，\\n参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一\\n个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计\\nContext 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，\\n参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
