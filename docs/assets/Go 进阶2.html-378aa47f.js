import{_ as i,W as a,X as e,a2 as t}from"./framework-5d92cd28.js";const n="/assets/image-20221121185643391-d0a1bdb2.png",c="/assets/image-20221121192633295-fdce964b.png",r="/assets/image-20221121200136416-f9003640.png",g="/assets/image-20221121201010865-6dd488e6.png",s="/assets/image-20221121201417761-03774900.png",o="/assets/image-20221121203243455-96272031.png",d="/assets/image-20221122192152594-89572afa.png",l="/assets/image-20221125143113712-f4bba844.png",p="/assets/image-20221125143755601-d1e0cfe2.png",h="/assets/image-20221126144640620-38c4c1f6.png",m="/assets/image-20221126151701928-25925ba1.png",f="/assets/image-20221126152033904-4c0626e8.png",u="/assets/image-20221126152220934-404db012.png",x={},_=t('<h2 id="知识" tabindex="-1"><a class="header-anchor" href="#知识" aria-hidden="true">#</a> 知识</h2><h3 id="context" tabindex="-1"><a class="header-anchor" href="#context" aria-hidden="true">#</a> context</h3><ul><li>context实例不可变，每次调用api，都会返回一个新创建的ctx</li><li>父级ctx控制底下所有子ctx,而子ctx连自己的父亲是谁都不清楚，因此父ctx错误，所有子ctx都错误，而子ctx错误不会影响到父ctx</li><li>可用于业务超时控制</li></ul><h4 id="withtimeout" tabindex="-1"><a class="header-anchor" href="#withtimeout" aria-hidden="true">#</a> WithTimeout</h4><p>超时给ctx发送错误</p><h4 id="context-err" tabindex="-1"><a class="header-anchor" href="#context-err" aria-hidden="true">#</a> context.Err</h4><p>context的管道没关闭前都返回nil,</p><p>关闭后会根据对应情况返回不同的错误</p><figure><img src="'+n+'" alt="image-20221121185643391" tabindex="0" loading="lazy"><figcaption>image-20221121185643391</figcaption></figure><figure><img src="'+c+'" alt="image-20221121192633295" tabindex="0" loading="lazy"><figcaption>image-20221121192633295</figcaption></figure><h4 id="超时控制" tabindex="-1"><a class="header-anchor" href="#超时控制" aria-hidden="true">#</a> 超时控制</h4><figure><img src="'+r+'" alt="image-20221121200136416" tabindex="0" loading="lazy"><figcaption>image-20221121200136416</figcaption></figure><figure><img src="'+g+'" alt="image-20221121201010865" tabindex="0" loading="lazy"><figcaption>image-20221121201010865</figcaption></figure><figure><img src="'+s+'" alt="image-20221121201417761" tabindex="0" loading="lazy"><figcaption>image-20221121201417761</figcaption></figure><h4 id="cancelctx" tabindex="-1"><a class="header-anchor" href="#cancelctx" aria-hidden="true">#</a> cancelCtx</h4><figure><img src="'+o+'" alt="image-20221121203243455" tabindex="0" loading="lazy"><figcaption>image-20221121203243455</figcaption></figure><figure><img src="'+d+'" alt="image-20221122192152594" tabindex="0" loading="lazy"><figcaption>image-20221122192152594</figcaption></figure><h3 id="sync" tabindex="-1"><a class="header-anchor" href="#sync" aria-hidden="true">#</a> sync</h3><h4 id="double-check" tabindex="-1"><a class="header-anchor" href="#double-check" aria-hidden="true">#</a> double-check</h4><p>双重检查，读写锁时可以用到。</p><figure><img src="'+l+'" alt="image-20221125143113712" tabindex="0" loading="lazy"><figcaption>image-20221125143113712</figcaption></figure><h4 id="mutex" tabindex="-1"><a class="header-anchor" href="#mutex" aria-hidden="true">#</a> mutex</h4><figure><img src="'+p+'" alt="image-20221125143755601" tabindex="0" loading="lazy"><figcaption>image-20221125143755601</figcaption></figure><h4 id="pool" tabindex="-1"><a class="header-anchor" href="#pool" aria-hidden="true">#</a> pool</h4><figure><img src="'+h+'" alt="image-20221126144640620" tabindex="0" loading="lazy"><figcaption>image-20221126144640620</figcaption></figure><p>先找自己私有的，再找自己共享的。还找不到就找别人（别的gorounte）共享的,还找不到就找victim(缓刑的，即将被垃圾回收的)，最后还没有就只能创建一个新的了。</p><figure><img src="'+m+'" alt="image-20221126151701928" tabindex="0" loading="lazy"><figcaption>image-20221126151701928</figcaption></figure><figure><img src="'+f+'" alt="image-20221126152033904" tabindex="0" loading="lazy"><figcaption>image-20221126152033904</figcaption></figure><figure><img src="'+u+'" alt="image-20221126152220934" tabindex="0" loading="lazy"><figcaption>image-20221126152220934</figcaption></figure><h2 id="功能" tabindex="-1"><a class="header-anchor" href="#功能" aria-hidden="true">#</a> 功能</h2><h3 id="优雅退出服务器" tabindex="-1"><a class="header-anchor" href="#优雅退出服务器" aria-hidden="true">#</a> 优雅退出服务器</h3><p>需求流程：</p><ul><li><p>拒绝新请求</p><p>每个服务结构体通过装饰器模式添加字段reject，要拒绝时将reject改为true。而每个新请求进去都先进入服务的ServeHTTP函数，然后才找到路由加载，故可在ServeHTTP头部添加判断reject，从而过滤新请求。</p></li><li><p>加载已有请求</p><p>关闭时sleep一段时间即可，或者实时监听每个请求的结束</p></li><li><p>关闭系统资源</p></li><li><p>执行回调</p></li></ul><p>如何强制退出：</p><p>第一次按ctrl c,先正常关闭，如果关闭超时或第二次按ctrl c 则强制退出。可嵌套select来实现监听两个阶段的信号。</p>',35),b=[_];function y(z,k){return a(),e("div",null,b)}const T=i(x,[["render",y],["__file","Go 进阶2.html.vue"]]);export{T as default};
