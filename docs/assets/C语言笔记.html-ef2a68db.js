import{_ as s,W as l,X as p,Y as a,Z as e,a0 as i,a2 as t,C as r}from"./framework-5d92cd28.js";const d={},c=t('<h2 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h2><h3 id="常量" tabindex="-1"><a class="header-anchor" href="#常量" aria-hidden="true">#</a> 常量</h3><p>一 字面常量</p><p>整型 实型 字符</p><p>二 符号常量</p><p>Define</p><p>unsigned int 表示无符号，即都为正数</p><p>0x十六进制</p><p>0八进制</p><p>Static int a=2; 只定义一次，不会再重新覆盖；而int a=2; 则每次遍历都会覆盖a的值</p><h3 id="变量类型" tabindex="-1"><a class="header-anchor" href="#变量类型" aria-hidden="true">#</a> 变量类型</h3><p>Float 精度六位</p><p>&quot;%s&quot; 整个输入作为一个串,并设置末尾的&#39;\\0&#39;</p><p>&quot;%ns&quot;,n为整数,读入的串最长不超过n,然后在末尾补&#39;\\0&#39;</p><p>%nf 读入的浮点数最多有n位整数,位数多于n,会截断。</p><p>&quot;%n[a-z]&quot; 读入最多n个字符,如果遇到非a-z的字符,停止</p><p>&quot;%[^=]&quot; 读入任意多的字符,直到遇到&quot;=&quot;停止</p><p>&quot;%n[^=]&quot; 读入&quot;=&quot;号前的至多n 个字符</p><h3 id="字符" tabindex="-1"><a class="header-anchor" href="#字符" aria-hidden="true">#</a> 字符</h3><p>[-] 数据向左靠拢</p><p>\\t 水平制表符 相当于加Tab 空四个空格</p><h3 id="计算" tabindex="-1"><a class="header-anchor" href="#计算" aria-hidden="true">#</a> 计算</h3><ul><li><p>++i，先加一在使用i</p><p>I++，先使用i在加一</p></li><li><p>强制类型转换运算符：</p><p>在前面加（int）如：（float）a</p><p>1/2结果为零，/是整数运算，可改成1.0/2或1/2.0；或强制类型转换（float）1/2</p></li><li><p>逗号运算符：</p><p>自左向右运算，最后一个数值即为赋值结果，如</p><p>a=3;a=(3 * 5,a * 4); 结果a=12.</p><p>a=3;a=(3 * 5,a * 4); 结果a=60.</p><p>(a=3 * 5 ,a * 4),a+5; 结果a=20.</p><p>I=3;j=-i++;结果 i=4,j=-3. j=-i++可看成j=-(i++)</p></li><li><p>优先级：赋值&lt;关系&lt;算数 如：</p><p>a=1,b=2;c<mark>a&gt;b; 结果：c</mark>0;</p></li><li><p>关系运算符结合性：自左向右 如：</p><p>x=95；100&gt;=x&gt;=90;</p><p>结果：0，假；过程：先100&gt;=95真，为1；在1&gt;=90,假，为0；故结果为零。</p></li><li><p>逻辑运算符优先级：</p><p>赋值&lt;||&lt;&amp;&amp;&lt;关系&lt;算术&lt;!</p></li><li><p>对所有整数取反=本身的相反数-1 如 ~9 = -10 ~-1=0</p></li></ul><h3 id="输入函数" tabindex="-1"><a class="header-anchor" href="#输入函数" aria-hidden="true">#</a> 输入函数</h3><ul><li><h4 id="scanf-s" tabindex="-1"><a class="header-anchor" href="#scanf-s" aria-hidden="true">#</a> scanf_s</h4></li></ul><p>scanf_s里面可加普通字符，但运行时不显示，要按原样打上去才显示</p><p>scanf_s 当遇到tab,空格，回车键，或遇到非法字符（即不符合如整数类型的），该数的读取即停止。</p><p>scanf() 函数接收字符串时的结束标志为回车或者空格</p><p>scanf_s(&quot;%d&quot;, &amp;a) != EOF,scanf_s中有多少个字符被成功格式化并赋值时，返回值则为成功读入的数量。故当scanf_s无字符赋值，则=EOF（end of file),于是跳出此表达式</p><ul><li><h4 id="stdin" tabindex="-1"><a class="header-anchor" href="#stdin" aria-hidden="true">#</a> stdin</h4></li></ul>',30),h={href:"https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA",target:"_blank",rel:"noopener noreferrer"},o=a("p",null,"fflush(stdin);，清空输入缓冲区并写入文本",-1),u=a("p",null,"setbuf(stdin,NULL),将缓冲区赋值为空",-1),f=a("h3",{id:"输出函数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#输出函数","aria-hidden":"true"},"#"),e(" 输出函数")],-1),b=a("h3",{id:"字符串",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#字符串","aria-hidden":"true"},"#"),e(" 字符串")],-1),_=a("p",null,"Char数组若是字符串，空间要 6多一个/0，如char a[6]={“hello”} 字符串输入要多一个空间，char a[6]=”hello”,char a[]=”hello”",-1),m=a("p",null,"用%s输出时，要遇到’/0’才能结束，所以数组要么扩大一个容量，要么初始化为字符串形式",-1),v={href:"https://blog.csdn.net/xvrixingkong/article/details/109841532",target:"_blank",rel:"noopener noreferrer"},g=t(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>要在末尾输入最大尺寸，如：
scanf_s(&quot;%s&quot;, pre,29);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><ul><li><p>数组一旦有一元素赋值，余下自动赋值为零。故将数组第一个元素赋值为零，可使剩下都为零。</p></li><li><p>省略掉了数组的大小，数组的大小则为初始化时元素的个数,如str[]</p></li><li><p>定义数组时对第一维的长度可以不指定，但第二维的长度不能省 如</p></li><li><p>只有字符串数组可以通过数组名来整体引用一个数组，整形不可以</p></li><li><p>若有说明static int a[3] [3];那么数组a中每个元素初值为0</p></li><li><p>拷贝数组，不可直接赋值</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>memcpy(arr, data,sizeof(data)); // 头文件 string.h
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="指针" tabindex="-1"><a class="header-anchor" href="#指针" aria-hidden="true">#</a> 指针</h3><ul><li><p>&amp;取地址，*取地址的内容</p><p>直接访问：按变量地址存取变量值 如i=3；</p><p>间接访问：通过存放变量地址的变量去访问变量 如 i_pointer=&amp;i;*i_pointer=20;</p><p>指针p+1是p+1*d（d为p指向变量所占的字节数）</p></li><li><p>int *a=(int * )malloc(n * sizeof(int));</p><p>介绍：可以当作数组使用，表示定义一个int类型的指针变量a，并申请n * sizeof(int)个字节（即4*n个字节）的存储空间。malloc是在C语言中是一个申请内存单元的函数。函数原型：void *malloc(unsigned size)</p><p>头文件 ：&lt;stdlib.h&gt;</p></li><li><p>p或str[]可作为一维数组的函数形参，*p[3]或str[][3]可作为二维数组的函数参数</p></li><li><p>char *gets_s(char *buffer,size_t sizeInCharacters); 头文件#include &lt;string.h&gt;</p></li><li><p>在用指针1查找字符串时需小心指针1的改变，应定义一个指针2储存原来的首地址，然后使用完指针1后，指针2再赋值给指针1</p></li><li><p>认清char* p[5]，malloc分配后为一个一维指针数组，即数组里所有元素都为指针</p></li><li><p>P[i]是第i行的首地址，指向下一个字符可p[i]=*(p+i)+1或p[i]++;</p></li><li><p>*P[i]相当与p[i] [0]，已是一个确切的位置和数据</p></li><li><p>Gets_s(<em>p[i]，20)报错是因为</em>p[i]已经赋值了是一个常量。</p></li><li><p>从而gets(char *str ) 说明里面参数要用地址，即p[i].</p></li><li><p>Free(链表的一个节点指针）相当于删除这个节点</p></li><li><p>scanf(&quot;%d&quot;,&amp;n); *p=n; 错，p指针还没有指向任何内容，是野指针，无法赋值</p></li></ul><h3 id="结构体" tabindex="-1"><a class="header-anchor" href="#结构体" aria-hidden="true">#</a> 结构体</h3><ul><li><p>可以定义一个struct 结构体函数，其返回值为结构体变量，因此可返回多个值，当然也需要结构体变量来接收，使用结构体指针的时候要为指针分配内存，因为系统不知道你的制作的struct Date的大小多少，且储存结构体的地址需要一个结构体大小的内存空间。如：</p><p>p = (struct Date*)malloc(sizeof(struct Date));</p></li><li><p>结构体之类出现 不允许使用不完整的类型 即此结构体未定义 当然有时候是你的结构体名称打错了，所以未定义就报错，还挺难发现的，就有点气了。</p></li></ul><h3 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h3><p>链表无非就两个点，一是结构储存着数据域(另一个结构体)和指针域(存储下一个结构体的地址，即指针)，二是给本身定义一个结构体指针，如此每个表便能拥有自身的指针(一个明确的地址)和下一个表的地址</p><h3 id="文件" tabindex="-1"><a class="header-anchor" href="#文件" aria-hidden="true">#</a> 文件</h3><ul><li><p>while (!feof(fp1)) 可以一直读取文件</p></li><li><p>Rewind(fp) 重置文件位置指针于文件开始处，以便读入数据</p></li><li><p>fprintf后，消息没有被写到文件的解决方法(类似于scanf)</p></li><li><p>由于缓存的原因，内容未写入文件。</p><p>1.在fopen之后，加句：setbuf(fp,NULL);</p><p>2.fprintf后面加上fflush(fp);</p></li><li><p>文件读取后要关闭文件或者重置到初始位置，否则如指针一般，会接着末尾读取数据，造成难以发现的错误</p></li><li><p>fscanf和scanf一样输入时数据之间默认以空格或回车隔开。</p><p>比如用scanf（&quot;%d%d&quot;,&amp;a,&amp;b）;在输入的时候，如果你想输入1和2.而你输入了12，则只认为输入了一个数据12.所以scanf失败。你必须输入1空格2，或者1回车2才能成功。fscanf也一样。在从二进制文件输入时，读入一个数据后要读入一个空格才能接着读下一个数据。</p><p>所以fprintf的时候要在数据之间显示的加空格。因为fprintf是对文件的写入，影响着fscanf的输出格式</p></li><li><p>fprintf成功写入但fsanf读取文件不成功还有可能是打开文件模式是’w’，而用rewind重置后仍处于这种模式下，无法读取</p></li><li><p>不管fgets还是fscanf，只要文件的数据传入，都需要变量来接收在打印出来</p></li><li><p>fputc(&#39;\\n&#39;, fp1); 在文本中添加’\\n’，可实现换行，添加’\\0’可视为字符串结束，同时feof(fp)=1为真</p></li><li><p>用fwrite读取时，下面最好不要加入额外的字符，如fputc(&#39;\\n&#39;, fp1); 会导致fread写入了空格，出现乱码。要么删除字符，要么在fread部分也加入同样的字符，保持对称关系，fscanf和fprintf同理</p></li><li><p>使用gets或者scanf若有输入问题（没有停顿，直接显示结果），要清除缓冲区，使用setbuf,否则缓冲区堵塞，会导致读入数据缺失</p></li><li><p>txt中文读取乱码</p><p>改一下记事本的格式从utf-8改成ansi的格式</p><p>同时附上如何改变编码格式，打开左上角文件，点击另存为 的时候，底下有一个选择格式，将utf-8换成ansi即可</p></li></ul><h3 id="switch和break" tabindex="-1"><a class="header-anchor" href="#switch和break" aria-hidden="true">#</a> switch和break</h3><p>当break用于开关语句switch中时,可使程序跳出switch而执行switch以后的语句。</p><p>而continue再switch中则跳过本次循环，后面语句都不执行</p><h2 id="功能" tabindex="-1"><a class="header-anchor" href="#功能" aria-hidden="true">#</a> 功能</h2><h3 id="vs快捷键" tabindex="-1"><a class="header-anchor" href="#vs快捷键" aria-hidden="true">#</a> vs快捷键</h3><p>注释: 先CTRL+K，然后CTRL+C</p><p>取消注释: 先CTRL+K，然后CTRL+U</p><h3 id="格式转换" tabindex="-1"><a class="header-anchor" href="#格式转换" aria-hidden="true">#</a> 格式转换</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// askii转字符
char c;
int a=32;
c=a; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><h3 id="消除vs中动态申请二维数组c6011-c6385-c6386的警告" tabindex="-1"><a class="header-anchor" href="#消除vs中动态申请二维数组c6011-c6385-c6386的警告" aria-hidden="true">#</a> 消除VS中动态申请二维数组C6011，C6385，C6386的警告]()</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 消除C6011警告</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;无法动态申请内存！\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vs2019【c-报错】e0144-const-char-类型的值不能用于初始化-char-类型的实体" tabindex="-1"><a class="header-anchor" href="#vs2019【c-报错】e0144-const-char-类型的值不能用于初始化-char-类型的实体" aria-hidden="true">#</a> VS2019【C++报错】E0144&quot;const char *&quot; 类型的值不能用于初始化 &quot;char *&quot; 类型的实体</h3><p>不改代码，修改项目属性。项目&gt;&gt;属性&gt;&gt;C/C++&gt;&gt;语言&gt;&gt;符合模式，将符合模式由是改为否（优点是不需要修改代码，缺点是每写新的项目就要修改一次设置）</p><h3 id="思考-为什么给指针动态分配空间可以当作数组用-而其他类型就不可以" tabindex="-1"><a class="header-anchor" href="#思考-为什么给指针动态分配空间可以当作数组用-而其他类型就不可以" aria-hidden="true">#</a> 思考：为什么给指针动态分配空间可以当作数组用，而其他类型就不可以</h3><p>个人解答：因为扩大空间同时新增了些地址，所以指针能通过指向不同地址来指定某一内存空间，于是可以输入输出。而其他变量即使扩大空间，依旧只能使用第一格的内存空间，多余空间算作废，并不能扩大存储的字节。</p><p>大部分指针问题都可以类比成数组把问题简单化。指针的指针可以变成二维数组.结构体的指针动态分配内存后变成一个一维数组，指向数组只需要指针就行，而不是指针的指针。</p><h3 id="报错-字符常量中的字符过多" tabindex="-1"><a class="header-anchor" href="#报错-字符常量中的字符过多" aria-hidden="true">#</a> 报错：字符常量中的字符过多</h3><p>如 str[100]={‘three’}; 在这里使用了单引号，即把three放进一个char大小的空间里，自然内存不够报。此单引号是代表一个字母</p><p>方法：应改成str[100]={“three”}; 改为双引号，即赋值的是一个字符串，每个数组位置只放一个字符，直到满为止。</p><h3 id="递归栈溢出" tabindex="-1"><a class="header-anchor" href="#递归栈溢出" aria-hidden="true">#</a> 递归栈溢出</h3>`,32),x={href:"https://blog.csdn.net/moqingxinai2008/article/details/79574086",target:"_blank",rel:"noopener noreferrer"},k=t(`<h3 id="报错-gets-找不到标识符。" tabindex="-1"><a class="header-anchor" href="#报错-gets-找不到标识符。" aria-hidden="true">#</a> 报错：“gets”: 找不到标识符。</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>有头文件仍无法使用gets()
把“gets”改成“gets_s”即可。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h2>`,3),q=a("li",null,[a("p",null,"网址：指向资源的指针；变量地址：指向变量的指针")],-1),C=a("li",null,[a("p",null,"#pragma once是一个比较常用的C/C++预处理指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次")],-1),w=a("li",null,[a("p",null,"如果其他文件要使用这个文件中定义的全局变量，则必须在使用前用“extern”做外部声明。如extern int day()")],-1),L=a("li",null,[a("p",null,"栈（stack）"),a("p",null,"又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。")],-1),E=a("li",null,[a("p",null,"不使用安全版函数 加 #define _CRT_SECURE_NO_WARNINGS")],-1),z={href:"https://zhidao.baidu.com/question/1802401192287142347.html",target:"_blank",rel:"noopener noreferrer"},N=a("div",{class:"language-text line-numbers-mode","data-ext":"text"},[a("pre",{class:"language-text"},[a("code",null,`名字在赋值号右边，就是代表值，如果在赋值号左边，就是代表地址
`)]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"})])],-1);function R(T,B){const n=r("ExternalLinkIcon");return l(),p("div",null,[c,a("p",null,[e("stdin是标准输入 std即standard（标准），in即input（输入），合起来就是标准输入。 一般就是指键盘输入到"),a("a",h,[e("缓冲区"),i(n)]),e("里的东西")]),o,u,f,b,_,m,a("p",null,[a("a",v,[e("scanf_s函数用于输入字符串时的问题"),i(n)])]),g,a("p",null,[a("a",x,[e("调节项目属性栈大小"),i(n)])]),k,a("ul",null,[q,C,w,L,E,a("li",null,[a("p",null,[a("a",z,[e("为什么scanf要用取地址&符"),i(n)])]),N])])])}const S=s(d,[["render",R],["__file","C语言笔记.html.vue"]]);export{S as default};
