import{_ as a,W as e,X as i,a2 as h}from"./framework-5d92cd28.js";const r={},d=h('<h3 id="面向对象编程" tabindex="-1"><a class="header-anchor" href="#面向对象编程" aria-hidden="true">#</a> 面向对象编程</h3><p>每个对象（类）有自身的属性和方法。</p><p>方法即对象的动作，只围绕自身属性进行，有很强的封闭性，因此结构清晰。</p><p>什么时候该写对象的方法呢，例如对自身属性的计算，可以写进方法。外部通过调用方法得到计算后的属性。</p><h3 id="计算机局部原理" tabindex="-1"><a class="header-anchor" href="#计算机局部原理" aria-hidden="true">#</a> 计算机局部原理</h3><p>计算机访问某个地址时，通常邻近的地址在未来大概率访问到。故计算机会预读，多读入该区域内容。</p><h3 id="多级缓存" tabindex="-1"><a class="header-anchor" href="#多级缓存" aria-hidden="true">#</a> 多级缓存</h3><p>若有一级缓存，二级缓存，一级缓存处理速度快，二级缓存容量大，双方要数据一致性。</p><ul><li>先将一级缓存数据更新，且标志为脏，表示两者缓存数据不一致了。</li><li>等到下次更新，发现该数据为脏，则将数据写入二级缓存，更新一级缓存，并标志为脏。</li></ul><p>如此减少二级缓存的访问，节约CPU资源</p><h3 id="加索引项" tabindex="-1"><a class="header-anchor" href="#加索引项" aria-hidden="true">#</a> 加索引项</h3><p>若对象为链表结构且数据过长，则每次获取都需要从头遍历链表，耗费时间。</p><p>故可以加个索引项，可直接访问某个对象的地址。经典空间换时间。</p><h3 id="后台分批处理" tabindex="-1"><a class="header-anchor" href="#后台分批处理" aria-hidden="true">#</a> 后台分批处理</h3><p>若一次计算量大，比如统计表的数据量，需要遍历来统计总数，太耗时间。</p><p>因此可以每加入一条记录，变量+1。以低资源长作业的后台替代高耗时的任务。</p><h3 id="分片分组处理" tabindex="-1"><a class="header-anchor" href="#分片分组处理" aria-hidden="true">#</a> 分片分组处理</h3><p>若数据量巨大，对于复制，查找操作效率降低，且单台机器容量有上限。因此经常将数据分组或分片处理。</p><p>如：</p><ul><li>mysql通过dble进行分库</li><li>linux的页管理也对所有的页分组，划分为一级页表和二级页表。而虚拟地址中有一级二级页号及页内偏移，便可以从一级找二级，二级找物理地址。</li><li>redis的map是并发安全的，在扩容时会复制旧map，这样会堵塞所有读写的线程，比较耗时。因此可采用分段锁策略，将数据放在map数组中，哪个map要扩容了，便加锁。这样不会影响其他map的读写。即一个map容易堵塞，则用多节点map,看起来像map分片了。</li></ul><h3 id="延迟初始化" tabindex="-1"><a class="header-anchor" href="#延迟初始化" aria-hidden="true">#</a> 延迟初始化</h3><p>一个对象的延迟初始化意味着该对象的创建将会延迟至第一次使用该对象时。主要用于提高性能，并减少程序内存要求。</p><h3 id="空间扩容" tabindex="-1"><a class="header-anchor" href="#空间扩容" aria-hidden="true">#</a> 空间扩容</h3><p>小空间时翻倍扩容，大空间时加一个常数或扩容四分之一。</p><p>小空间若有扩容需求，则未来大概率还要扩容，因此翻倍扩容，提前分配，减少内存分配次数。</p><p>大空间还翻倍扩容则容易浪费很多内存空间，因此小幅度扩容。</p>',26),p=[d];function n(t,l){return e(),i("div",null,p)}const s=a(r,[["render",n],["__file","Coding思考.html.vue"]]);export{s as default};
