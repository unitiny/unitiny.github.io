import{_ as s,W as n,X as t,a2 as l,Y as e,Z as a}from"./framework-5d92cd28.js";const i={},d=l(`<h2 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h2><h4 id="创建项目" tabindex="-1"><a class="header-anchor" href="#创建项目" aria-hidden="true">#</a> 创建项目</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm init vite@latest &lt;project-name&gt; -- --template vue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="安装scss" tabindex="-1"><a class="header-anchor" href="#安装scss" aria-hidden="true">#</a> 安装scss</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm install --save-dev sass
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="安装vuex" tabindex="-1"><a class="header-anchor" href="#安装vuex" aria-hidden="true">#</a> 安装vuex</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm install vuex@next --save
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h2><h3 id="setup" tabindex="-1"><a class="header-anchor" href="#setup" aria-hidden="true">#</a> setup</h3><p>setup() 实例创建之前运行，不需要使用this</p><p>setup() 目的为把某个数据的方法统一放置一块，可读性高</p><p>ref</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>setup中创建数据要引入ref，ref(0)返回一个带有value的对象，
此时改变value，由于对象具有指针性质，因此有响应式数据的效果。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>reactive</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>创建对象引入reactive({name:&quot;tom&quot;，age:18})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>watch</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>监听数据，也得从vue引入

如
const count = ref(0)
watch(count, (newVal, oldVal) =&gt; {
  console.log(newVal, oldVal);
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>script setup</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>引入组件 不需要注册
定义变量不需要return暴露出去
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="功能" tabindex="-1"><a class="header-anchor" href="#功能" aria-hidden="true">#</a> 功能</h2><h3 id="如何监听vuex中数组的变化" tabindex="-1"><a class="header-anchor" href="#如何监听vuex中数组的变化" aria-hidden="true">#</a> 如何监听vuex中数组的变化</h3>`,21),r=e("p",null,[a("但数组变化时，使用this."),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"s"),e("mi",null,"e"),e("mi",null,"t"),e("mo",{stretchy:"false"},"("),e("mo",{stretchy:"false"},")"),e("mtext",null,"修改数组某一项，就能检测到数组更新。但"),e("mi",null,"v"),e("mi",null,"u"),e("mi",null,"e"),e("mi",null,"x"),e("mtext",null,"是写在"),e("mi",null,"j"),e("mi",null,"s"),e("mtext",null,"中的，没有"),e("mi",null,"t"),e("mi",null,"h"),e("mi",null,"i"),e("mi",null,"s"),e("mi",{mathvariant:"normal"},".")]),e("annotation",{encoding:"application/x-tex"},"set()修改数组某一项，就能检测到数组更新。但vuex是写在js中的，没有this.")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal"},"se"),e("span",{class:"mord mathnormal"},"t"),e("span",{class:"mopen"},"("),e("span",{class:"mclose"},")"),e("span",{class:"mord cjk_fallback"},"修改数组某一项，就能检测到数组更新。但"),e("span",{class:"mord mathnormal"},"vu"),e("span",{class:"mord mathnormal"},"e"),e("span",{class:"mord mathnormal"},"x"),e("span",{class:"mord cjk_fallback"},"是写在"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.05724em"}},"j"),e("span",{class:"mord mathnormal"},"s"),e("span",{class:"mord cjk_fallback"},"中的，没有"),e("span",{class:"mord mathnormal"},"t"),e("span",{class:"mord mathnormal"},"hi"),e("span",{class:"mord mathnormal"},"s"),e("span",{class:"mord"},".")])])]),a("set这属性，即可使用JSON.parse(JSON.stringify(state.Arr))来让外部能检测到数组更新")],-1),c=e("p",null,"然后组件中使用computed或者watch监听数据变化即可",-1),u=e("h2",{id:"思考",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#思考","aria-hidden":"true"},"#"),a(" 思考")],-1),m=e("h3",{id:"为什么要用响应式api",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么要用响应式api","aria-hidden":"true"},"#"),a(" 为什么要用响应式api?")],-1),o=e("p",null,"vue2是通过劫持改变的对象来通知订阅者哪个变量修改了，进而重新渲染视图。",-1),h=e("p",null,"而vue3则需要通过响应式api来定义一个proxy的代理，来监听数据变化，进而重新渲染视图。普通变量也可展示，然而当变量变化后，视图不会更新。",-1),v=[d,r,c,u,m,o,h];function p(x,b){return n(),t("div",null,v)}const _=s(i,[["render",p],["__file","Vue3 笔记.html.vue"]]);export{_ as default};
